
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>川甘环线（真实导航几何 · 全段预取 · 更透明标注 · 自适应缩放）</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<style>
  :root {
    --chip-radius: 10px;
    --chip-shadow: 0 2px 6px rgba(0,0,0,0.18);
    --chip-font: 12px;
    --chip-weight: 800;
    --sysfont: system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif;
  }
  html, body, #map { height: 100%; margin: 0; font-family: var(--sysfont); }
  .legend { position: absolute; right: 10px; top: 10px; z-index: 1001; background: rgba(255,255,255,0.95);
            padding: 8px 10px; border:1px solid #999; border-radius:10px; font-size: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.15); }
  .legend .row { display:flex; align-items:center; gap:8px; margin:3px 0; } .legend .swatch { width:14px; height:14px; border-radius:3px; border:1px solid #666; }
  .overlay { position: absolute; left: 10px; top: 10px; z-index: 1001; background: rgba(255,255,255,0.95);
             padding: 10px 14px; border: 1px solid #999; border-radius: 10px; font-size: 13px; box-shadow: 0 2px 6px rgba(0,0,0,0.15); }
  .overlay .row { display:flex; align-items:center; gap:10px; }
  .chip { border-radius: var(--chip-radius) !important; box-shadow: var(--chip-shadow) !important; border: 1px solid rgba(0,0,0,0.35) !important;
          -webkit-backface-visibility: hidden; transform: translateZ(0); display: inline-flex; align-items: center; gap: 8px;
          padding: 6px 10px; font-size: var(--chip-font); font-weight: var(--chip-weight); line-height: 1; white-space: nowrap; font-family: var(--sysfont); }
  .chip--point { padding: 4px 8px; }
  .leaflet-div-icon { background: transparent !important; border: 0 !important; }
  .flag-svg { width: 22px; height: 22px; transform: translate(0,-18px); }
  .segchk { appearance: none; -webkit-appearance: none; width: 16px; height: 16px; border-radius: 4px; border: 2px solid rgba(255,255,255,0.9);
            outline: none; display: inline-block; position: relative; cursor: pointer; background: rgba(255,255,255,0.25); }
  .segchk::after { content: "✓"; position: absolute; top: -2px; left: 2px; font-size: 14px; color: #fff; opacity: 0; transform: scale(0.5); transition: all .15s ease; }
  .segchk:checked { background: rgba(0,0,0,0.3); } .segchk:checked::after { opacity: 1; transform: scale(1); }
  .dimmed { filter: saturate(35%) brightness(0.95); opacity: 0.5; }
  .toggle-wrap { position:absolute; right:10px; bottom:10px; z-index:1002; display:flex; gap:10px; }
  .toggle-btn { background:#111; color:#fff; padding:10px 12px; border-radius:12px; border:1px solid #333; cursor:pointer; font-weight:800; font-size:12px; box-shadow:0 2px 6px rgba(0,0,0,.2); }
  .toggle-btn .hint { font-weight:600; opacity:.8; margin-left:6px; }
  .reset-btn { background:#f43f5e; color:#fff; padding:10px 12px; border-radius:12px; border:1px solid #b91c1c; cursor:pointer; font-weight:800; font-size:12px; box-shadow:0 2px 6px rgba(0,0,0,.15); }
  .badge { position:absolute; right:10px; bottom:56px; z-index:1002; background:#111; color:#fff; padding:6px 10px; border-radius:10px; font-weight:800; font-size:12px; border:1px solid #333; box-shadow:0 2px 6px rgba(0,0,0,.2); display:none; }
</style>
</head>
<body>
<div id="map"></div>
<div class="overlay">
  <div class="row">
    <div style="font-weight:800;font-size:14px;">总里程：<span id="total_km">--</span> km</div>
    <div style="font-weight:700;">剩余：<span id="remain_km">--</span> km</div>
    <button id="resetBtn" class="reset-btn" title="重置所有勾选">重置</button>
  </div>
</div>
<div class="legend">
  <div style="font-weight:700;margin-bottom:4px;">D1–D8 图例</div>
  <div class="row"><span class="swatch" style="background:#d62728"></span> D1</div>
  <div class="row"><span class="swatch" style="background:#1f77b4"></span> D2</div>
  <div class="row"><span class="swatch" style="background:#2ca02c"></span> D3</div>
  <div class="row"><span class="swatch" style="background:#ff7f0e"></span> D4</div>
  <div class="row"><span class="swatch" style="background:#9467bd"></span> D5</div>
  <div class="row"><span class="swatch" style="background:#8c564b"></span> D6</div>
  <div class="row"><span class="swatch" style="background:#e377c2"></span> D7</div>
  <div class="row"><span class="swatch" style="background:#7f7f7f"></span> D8</div>
</div>
<div class="toggle-wrap">
  <button id="toggleRoute" class="toggle-btn">切换为直线连线<span class="hint">（当前：导航路径）</span></button>
</div>
<div id="badge" class="badge">预取路线… 0%</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script>
const dayColors = { D1:"#d62728", D2:"#1f77b4", D3:"#2ca02c", D4:"#ff7f0e", D5:"#9467bd", D6:"#8c564b", D7:"#e377c2", D8:"#7f7f7f" };
function luminance(hex){ const c=hex.replace('#',''); const r=parseInt(c.slice(0,2),16), g=parseInt(c.slice(2,4),16), b=parseInt(c.slice(4,6),16); return 0.299*r+0.587*g+0.114*b; }
function rgba(hex,a=0.65){ const c=hex.replace('#',''); const r=parseInt(c.slice(0,2),16), g=parseInt(c.slice(2,4),16), b=parseInt(c.slice(4,6),16); return `rgba(${r},${g},${b},${a})`; }

// Google-style polyline encoder/decoder
const PolyUtil = {
  encode(coords){ let lastLat=0,lastLng=0,result=''; for(const [lat,lng] of coords){ let ilat=Math.round(lat*1e5), ilng=Math.round(lng*1e5);
    let dlat=ilat-lastLat, dlng=ilng-lastLng; lastLat=ilat; lastLng=ilng;
    for(let v of [dlat, dlng]){ v<<=1; if(v<0) v=~v; while(v>=0x20){ result+=String.fromCharCode((0x20|(v&0x1f))+63); v>>=5; } result+=String.fromCharCode(v+63); }
  } return result; },
  decode(str){ let index=0, lat=0, lng=0, coords=[]; while(index<str.length){ let b, shift=0, result=0; do{ b=str.charCodeAt(index++)-63; result|=(b&0x1f)<<shift; shift+=5; }while(b>=0x20);
    let dlat=((result&1)?~(result>>1):(result>>1)); shift=0; result=0; do{ b=str.charCodeAt(index++)-63; result|=(b&0x1f)<<shift; shift+=5; }while(b>=0x20);
    let dlng=((result&1)?~(result>>1):(result>>1)); lat+=dlat; lng+=dlng; coords.push([lat*1e-5,lng*1e-5]); } return coords; }
};

const points = [
  ["成都",30.658,104.064,"D1",500],
  ["松潘",32.6386,103.5975,"D1",2850],
  ["川主寺镇",32.77682,103.61733,"D1",3000],
  ["九寨沟",33.20000,103.90000,"D1",2000],
  ["神仙池",33.25000,103.65000,"D2",3300],
  ["迭部",34.0560,103.2219,"D2",3000],
  ["扎尕那",34.23595,103.18631,"D3",3000],
  ["洛克之路",34.24800,103.18000,"D3",3100],
  ["米拉日巴佛阁",35.00673,102.91556,"D3",2900],
  ["合作",34.99837,102.90999,"D3",2900],
  ["夏河",35.20256,102.52173,"D4",2900],
  ["拉卜楞寺",35.19306,102.50694,"D4",2900],
  ["桑科草原",35.11477,102.42877,"D4",3200],
  ["碌曲",34.59042,102.48892,"D4",3500],
  ["郎木寺",34.09139,102.63639,"D4",3300],
  ["唐克",33.4106,102.46754,"D5",3400],
  ["阿坝",32.90502,101.70192,"D6",3300],
  ["各莫寺",32.98,101.38,"D6",3400],
  ["莲宝叶则",33.233,101.08,"D6",4000],
  ["阿坝（返）",32.90502,101.70192,"D6",3300],
  ["观音桥",31.79968,101.65295,"D7",2500],
  ["玉科草原",31.28858,101.17983,"D7",3800],
  ["党岭",30.8521,101.9338,"D7",3200],
  ["丹巴",30.877,101.886,"D7",1900],
  ["巴郎山",30.889,102.869,"D8",4460],
  ["成都（终）",30.658,104.064,"D8",500]
];
const order = ["成都","松潘","川主寺镇","九寨沟","神仙池","迭部","扎尕那","洛克之路","米拉日巴佛阁","合作","夏河","拉卜楞寺","桑科草原","碌曲","郎木寺","唐克","阿坝","各莫寺","莲宝叶则","阿坝（返）","观音桥","玉科草原","党岭","丹巴","巴郎山","成都（终）"];
const pt = {}; points.forEach(([n,lat,lon,day,elev])=>pt[n]={lat,lon,day,elev});

function haversineKm(lat1,lon1,lat2,lon2){ const R=6371, dLat=(lat2-lat1)*Math.PI/180, dLon=(lon2-lon1)*Math.PI/180;
  const a=Math.sin(dLat/2)**2+Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2; return 2*R*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)); }
function roadKmApprox(lat1,lon1,lat2,lon2){ return Math.round(haversineKm(lat1,lon1,lat2,lon2)*1.35); }

const map=L.map('map', { zoomControl:true }).setView([30.658,104.064],9); // 起点更近一点
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:18,attribution:'&copy; OpenStreetMap'}).addTo(map);

function setTotals(total,remain){ document.getElementById('total_km').textContent=total; document.getElementById('remain_km').textContent=remain; }

const placed=[];
function willOverlap(ptA,thr=22){ for(const p of placed){ const dx=ptA.x-p.x,dy=ptA.y-p.y; if(Math.sqrt(dx*dx+dy*dy)<thr) return true; } return false; }
function spiralOffsets(n=28,step=0.001){ const arr=[]; for(let i=0;i<n;i++){ const ang=i*0.9,r=(i+1)*step; arr.push([Math.sin(ang)*r,Math.cos(ang)*r]); } return arr; }
const OFFSETS=spiralOffsets(28,0.001);

const pointLabelRefs=[];
function addPointLabel(name,lat,lon,day,elev){
  const color=dayColors[day]||'#333', bg=rgba(color,0.65);
  L.circleMarker([lat,lon],{radius:4,weight:2,color,fillColor:color,fillOpacity:1}).addTo(map);
  let finalLat=lat,finalLon=lon,placedPt=null;
  for(const [dlat,dlon] of OFFSETS){ const tLat=lat+dlat,tLon=lon+dlon; const ptScreen=map.latLngToLayerPoint([tLat,tLon]);
    if(!willOverlap(ptScreen)){ finalLat=tLat; finalLon=tLon; placedPt=ptScreen; break; } }
  if(!placedPt) placedPt=map.latLngToLayerPoint([finalLat,finalLon]); placed.push(placedPt);
  const tagHtml=`<div class="chip chip--point dynfs" data-kind="point" style="background:${bg} !important;color:#fff !important;border-color:${color} !important;">${day} ${name}｜${elev} m</div>`;
  const mk = L.marker([finalLat,finalLon],{icon:L.divIcon({className:'',html:tagHtml})}).addTo(map);
  pointLabelRefs.push(mk);
}

function flagIcon(){
  const svg=`<svg class="flag-svg" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
    <defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="0"><stop offset="0" stop-color="#ff4d4f"/><stop offset="1" stop-color="#d32029"/></linearGradient></defs>
    <path d="M14 8 v48" stroke="#444" stroke-width="4" />
    <path d="M18 10 C34 6, 40 20, 56 14 L56 34 C40 40, 34 24, 18 28 Z" fill="url(#g)" stroke="#8b0000" stroke-width="2" />
    <circle cx="14" cy="58" r="4" fill="#666"/>
  </svg>`;
  return L.divIcon({className:'', html:svg, iconSize:[22,22], iconAnchor:[11,20]});
}

const segments=[], amapLinks=[]; let totalKm=0;
for(let i=0;i<order.length-1;i++){
  const a=order[i], b=order[i+1]; const A=pt[a], B=pt[b];
  const dist=roadKmApprox(A.lat,A.lon,B.lat,B.lon); totalKm+=dist; const day=A.day;
  const amap=`https://uri.amap.com/navigation?from=${A.lon},${A.lat},${encodeURIComponent(a)}&to=${B.lon},${B.lat},${encodeURIComponent(b)}&mode=car&src=chatgpt`;
  amapLinks.push(amap);
  segments.push({from:a,to:b,day,dist,A,B});
}
setTotals(totalKm,totalKm);

// ---- REAL NAV CACHE (compressed) ----
const NAV_CACHE_KEY = "nav_polyline_v2";
function getNavCache(){ try{ return JSON.parse(localStorage.getItem(NAV_CACHE_KEY)||"{}"); }catch(e){ return {}; } }
function setNavCache(obj){ localStorage.setItem(NAV_CACHE_KEY, JSON.stringify(obj)); }
function segKey(A,B){ return `${A.lat.toFixed(5)},${A.lon.toFixed(5)}_${B.lat.toFixed(5)},${B.lon.toFixed(5)}`; }

async function fetchNavPolyline(A,B, tries=4){
  const url = `https://router.project-osrm.org/route/v1/driving/${A.lon},${A.lat};${B.lon},${B.lat}?overview=full&geometries=geojson`;
  for(let i=0;i<tries;i++){
    try{
      const r = await fetch(url); if(!r.ok) throw new Error('bad status');
      const j = await r.json();
      const coords = j.routes && j.routes[0] && j.routes[0].geometry && j.routes[0].geometry.coordinates;
      if(!coords) throw new Error('no geometry');
      const latlngs = coords.map(([lng,lat])=>[lat,lng]);
      return PolyUtil.encode(latlngs);
    }catch(e){ if(i===tries-1) throw e; await new Promise(res=>setTimeout(res, 700)); }
  }
}

async function prefetchAllNav(force=false){
  const badge = document.getElementById('badge');
  const cache = getNavCache();
  let done=0, total=segments.length;
  badge.style.display='block';
  badge.textContent = `预取路线… 0%`;
  const jobs = segments.map(async (seg, idx)=>{
    const key = segKey(seg.A, seg.B);
    if(!force && cache[key]){ done++; badge.textContent = `预取路线… ${Math.round(done/total*100)}%`; return; }
    try{
      const enc = await fetchNavPolyline(seg.A, seg.B);
      cache[key] = enc;
    }catch(e){
      // keep trying later; set a minimal straight fallback now
      cache[key] = cache[key] || PolyUtil.encode([[seg.A.lat,seg.A.lon],[seg.B.lat,seg.B.lon]]);
    }finally{
      done++; badge.textContent = `预取路线… ${Math.round(done/total*100)}%`;
    }
  });
  await Promise.all(jobs);
  setNavCache(cache);
  setTimeout(()=>{ badge.style.display='none'; }, 500);
}

function decodeSegPolyline(seg){
  const cache = getNavCache();
  const key = segKey(seg.A, seg.B);
  const enc = cache[key];
  if(!enc) return null;
  return PolyUtil.decode(enc);
}

// ---------- drawing & UI ----------
let modeActual=true;
const polyRefs=[], arrowRefs=[], labelRefs=[], checkRefs=[], pointLabelRefs2=[];

function clearPolylines(){
  polyRefs.forEach(pl=>{ if(pl){ map.removeLayer(pl); } });
  arrowRefs.forEach(ar=>{ if(ar){ map.removeLayer(ar); } });
  polyRefs.length=0; arrowRefs.length=0;
}

function buildStraight(){
  clearPolylines();
  segments.forEach((seg,idx)=>{
    const color=dayColors[seg.day]||'#333'; const bg=rgba(color,0.65);
    const line=L.polyline([[seg.A.lat,seg.A.lon],[seg.B.lat,seg.B.lon]],{color,weight:5,opacity:0.95}).addTo(map).bindTooltip("高德导航（点击打开）",{sticky:true});
    line.on('click',()=> window.open(amapLinks[idx],'_blank'));
    polyRefs[idx]=line;
    if(!labelRefs[idx]){
      const mid=[(seg.A.lat+seg.B.lat)/2,(seg.A.lon+seg.B.lon)/2];
      const html=`<div class="chip dynfs" data-kind="seg" id="seglabel_${idx}" style="background:${bg} !important;color:#fff !important;border-color:${color} !important;">
        <input type="checkbox" class="segchk" id="segcb_${idx}" data-idx="${idx}" data-dist="${seg.dist}" />
        <label for="segcb_${idx}" style="margin:0;cursor:pointer;">${seg.day} · ${seg.from} → ${seg.to} · ${seg.dist} km</label>
      </div>`;
      const marker=L.marker(mid,{icon:L.divIcon({className:'',html})}).addTo(map);
      labelRefs[idx]=marker;
      setTimeout(()=>{ const el=document.getElementById(`segcb_${idx}`); if(el) checkRefs[idx]=el; },0);
    }
  });
  applySequentialRules(); updateVisualsFromChecks(); applyZoomFont();
}

function arrowAtMid(latlngs, color){
  const midIdx = Math.floor(latlngs.length/2);
  const a = latlngs[midIdx-1]||latlngs[0], b = latlngs[midIdx+1]||latlngs[latlngs.length-1];
  const ang = Math.atan2(b[0]-a[0], b[1]-a[1]) * 180/Math.PI;
  const svg = `<svg width="20" height="20" viewBox="0 0 20 20" style="transform: rotate(${-(ang)}deg);">
    <path d="M3 10 L13 10 M10 6 L14 10 L10 14" stroke="${color}" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>`;
  return L.marker(latlngs[midIdx], { icon: L.divIcon({className:'', html:svg, iconSize:[20,20], iconAnchor:[10,10]})});
}

function buildActualFromCache(){
  clearPolylines();
  segments.forEach((seg, idx)=>{
    const color=dayColors[seg.day]||'#333';
    const latlngs = decodeSegPolyline(seg) || [[seg.A.lat,seg.A.lon],[seg.B.lat,seg.B.lon]];
    const line=L.polyline(latlngs,{color,weight:5,opacity:0.95}).addTo(map).bindTooltip("高德导航（点击打开）",{sticky:true});
    line.on('click',()=> window.open(amapLinks[idx],'_blank'));
    polyRefs[idx]=line;
    const arrow = arrowAtMid(latlngs, color).addTo(map);
    arrowRefs[idx]=arrow;
    if(checkRefs[idx] && checkRefs[idx].checked){ if(line._path){ line._path.style.filter="saturate(35%) brightness(0.95)"; line._path.style.opacity="0.45"; } }
  });
  applyZoomFont();
}

document.getElementById('toggleRoute').addEventListener('click', ()=>{
  modeActual = !modeActual;
  if(modeActual){
    buildActualFromCache();
    document.getElementById('toggleRoute').innerHTML='切换为直线连线<span class="hint">（当前：导航路径）</span>';
  } else {
    buildStraight();
    document.getElementById('toggleRoute').innerHTML='切换为导航路径<span class="hint">（当前：直线）</span>';
  }
});

// ---- sequence, persistence, reset ----
const STORAGE_KEY="chuan_gan_route_checked_indices_v13";
function persistState(){ const arr=checkRefs.map(el=> el&&el.checked?1:0); localStorage.setItem(STORAGE_KEY,JSON.stringify(arr)); }
function loadState(){ try{ const raw=localStorage.getItem(STORAGE_KEY); if(!raw) return null; const arr=JSON.parse(raw); return Array.isArray(arr)?arr.map(v=>v?1:0):null; }catch(e){ return null; } }

function applySequentialRules(){
  checkRefs.forEach(el=>{ if(el) el.disabled=true; });
  let firstUnchecked=checkRefs.findIndex(el=> el && !el.checked);
  if(firstUnchecked===-1) firstUnchecked=checkRefs.length-1;
  if(checkRefs[firstUnchecked]) checkRefs[firstUnchecked].disabled=false;
}
function updateVisualsFromChecks(){
  let checkedDist=0;
  checkRefs.forEach((el,i)=>{
    if(!el) return;
    const dist=parseInt(el.getAttribute('data-dist')||'0',10);
    const poly=polyRefs[i], labelMarker=labelRefs[i];
    if(el.checked){ checkedDist+=dist; if(poly&&poly._path){ poly._path.style.filter="saturate(35%) brightness(0.95)"; poly._path.style.opacity="0.45"; }
      if(labelMarker){ const nd=labelMarker.getElement(); if(nd) nd.classList.add('dimmed'); } }
    else { if(poly&&poly._path){ poly._path.style.filter=""; poly._path.style.opacity="0.95"; }
      if(labelMarker){ const nd=labelMarker.getElement(); if(nd) nd.classList.remove('dimmed'); } }
  });
  const sum = segments.reduce((a,s)=>a+s.dist,0);
  setTotals(sum, Math.max(0, sum-checkedDist));
}
function restoreFromStorage(){
  const arr=loadState(); if(!arr){ applySequentialRules(); updateVisualsFromChecks(); return; }
  let last=-1; for(let i=0;i<arr.length;i++){ if(arr[i]===1){ if(i===last+1){ if(checkRefs[i]) checkRefs[i].checked=true; last=i; } else { break; } } else { break; } }
  applySequentialRules(); updateVisualsFromChecks();
}
document.addEventListener('change', e=>{
  const t=e.target;
  if(t && t.classList.contains('segchk')){
    const idx=parseInt(t.getAttribute('data-idx'),10); if(!Number.isFinite(idx)) return;
    const prev=idx-1; if(prev>=0 && (!checkRefs[prev] || !checkRefs[prev].checked)){ t.checked=false; return; }
    if(!t.checked){ for(let j=idx+1;j<checkRefs.length;j++){ if(checkRefs[j]) checkRefs[j].checked=false; } }
    applySequentialRules(); updateVisualsFromChecks(); persistState();
  }
});

document.getElementById('resetBtn').addEventListener('click',()=>{
  checkRefs.forEach((el,i)=>{ if(el){ el.checked=false; }});
  localStorage.removeItem(STORAGE_KEY);
  applySequentialRules();
  updateVisualsFromChecks();
});

function applyZoomFont(){
  const z = map.getZoom();
  // 更明显的缩放：在 z=6 时 ~0.7 倍，z=10 时 ~1.4 倍
  const scale = Math.max(0.6, Math.min(1.6, 0.2*(z-8) + 1));
  const hideThreshold = 5;
  document.querySelectorAll('.dynfs').forEach(el=>{
    if(z <= hideThreshold){ el.style.display = 'none'; }
    else { el.style.display = 'inline-flex'; el.style.transform = `scale(${scale})`; el.style.transformOrigin = 'left center'; }
  });
}
map.on('zoomend', applyZoomFont);

// Init
(async function init(){
  points.forEach(([n,lat,lon,day,elev])=> addPointLabel(n,lat,lon,day,elev));
  const startName = points.find(p=>p[3]==="D1")[0]; const s = pt[startName];
  L.marker([s.lat, s.lon], {icon: flagIcon()}).addTo(map);
  buildStraight(); // 构建 DOM（段标签/复选框）
  // 强制预取所有段（首次），保证“全部导航路径”可用；之后秒开
  await prefetchAllNav(true);
  buildActualFromCache();
  applyZoomFont();
})();
</script>
</body>
</html>
"""
path = "/mnt/data/川甘环线.html"
with open(path, "w", encoding="utf-8") as f:
    f.write(html)
path
