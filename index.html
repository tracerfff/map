# Build a "clean & final" single-file HTML:
# - No stray header text
# - Point-name labels use EXACT same style as route labels (same font & colored background)
# - Strong background coloring with !important to beat any external CSS
# - Sequential checkboxes + persistence + desaturation on checked
# - Anti-overlap for point labels
html = r"""<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>å·ç”˜ç¯çº¿ï¼ˆç»Ÿä¸€åº•è‰²ä¸å­—ä½“ Â· é¡ºåºå‹¾é€‰ Â· æŒä¹…åŒ– Â· é˜²é®æŒ¡ï¼‰</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<style>
  :root {
    --chip-radius: 10px;
    --chip-shadow: 0 2px 6px rgba(0,0,0,0.18);
    --chip-font: 12px;
    --chip-weight: 800;
    --sysfont: system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif;
  }
  html, body, #map { height: 100%; margin: 0; font-family: var(--sysfont); }
  .legend {
    position: absolute; right: 10px; top: 10px; z-index: 1001;
    background: rgba(255,255,255,0.95); padding: 8px 10px; border:1px solid #999; border-radius:10px;
    font-size: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  }
  .legend .row { display:flex; align-items:center; gap:8px; margin:3px 0; }
  .legend .swatch { width:14px; height:14px; border-radius:3px; border:1px solid #666; }
  .overlay {
    position: absolute; left: 10px; top: 10px; z-index: 1001;
    background: rgba(255,255,255,0.95); padding: 10px 14px; border: 1px solid #999; border-radius: 10px;
    font-size: 13px; box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  }
  /* ç»Ÿä¸€ç”¨ .chip ä½œä¸ºâ€œè·¯çº¿æ ‡ç­¾ + åœ°åæ ‡ç­¾â€çš„åº•å±‚æ ·å¼ */
  .chip {
    border-radius: var(--chip-radius) !important;
    box-shadow: var(--chip-shadow) !important;
    border: 1px solid rgba(0,0,0,0.35) !important;
    -webkit-backface-visibility: hidden;
    transform: translateZ(0);
    display: inline-flex; align-items: center; gap: 8px;
    padding: 6px 10px;
    font-size: var(--chip-font); font-weight: var(--chip-weight);
    line-height: 1; white-space: nowrap;
    font-family: var(--sysfont);
  }
  /* åœ°åæ ‡ç­¾ä¸“ç”¨ï¼ˆç¨å°ä¸€ç‚¹ç‚¹ï¼‰ */
  .chip--point { padding: 4px 8px; }
  .leaflet-div-icon { background: transparent !important; border: 0 !important; }
  .flag { font-size: 20px; line-height: 20px; transform: translate(0,-18px); }
  /* æ¼‚äº®çš„å‹¾é€‰æ¡† */
  .segchk { appearance: none; -webkit-appearance: none; width: 16px; height: 16px;
            border-radius: 4px; border: 2px solid rgba(255,255,255,0.9); outline: none;
            display: inline-block; position: relative; cursor: pointer; background: rgba(255,255,255,0.25); }
  .segchk::after { content: "âœ“"; position: absolute; top: -2px; left: 2px; font-size: 14px; color: #fff;
    opacity: 0; transform: scale(0.5); transition: all .15s ease; }
  .segchk:checked { background: rgba(0,0,0,0.3); }
  .segchk:checked::after { opacity: 1; transform: scale(1); }
  /* å‹¾é€‰åé™é¥±å’Œ */
  .dimmed { filter: saturate(35%) brightness(0.95); opacity: 0.5; }
</style>
</head>
<body>
<div id="map"></div>

<div class="overlay">
  <div style="font-weight:800;font-size:14px;">æ€»é‡Œç¨‹ï¼š<span id="total_km">--</span> km</div>
  <div style="margin-top:6px;font-weight:700;">å‰©ä½™é‡Œç¨‹ï¼š<span id="remain_km">--</span> km</div>
  <div style="margin-top:4px;font-size:12px;color:#666;">æŒ‰é¡ºåºå‹¾é€‰ï¼›åˆ·æ–°åè‡ªåŠ¨æ¢å¤ä¸Šæ¬¡è¿›åº¦</div>
</div>

<div class="legend">
  <div style="font-weight:700;margin-bottom:4px;">D1â€“D8 å›¾ä¾‹</div>
  <div class="row"><span class="swatch" style="background:#d62728"></span> D1</div>
  <div class="row"><span class="swatch" style="background:#1f77b4"></span> D2</div>
  <div class="row"><span class="swatch" style="background:#2ca02c"></span> D3</div>
  <div class="row"><span class="swatch" style="background:#ff7f0e"></span> D4</div>
  <div class="row"><span class="swatch" style="background:#9467bd"></span> D5</div>
  <div class="row"><span class="swatch" style="background:#8c564b"></span> D6</div>
  <div class="row"><span class="swatch" style="background:#e377c2"></span> D7</div>
  <div class="row"><span class="swatch" style="background:#7f7f7f"></span> D8</div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script>
const dayColors = {
  D1:"#d62728", D2:"#1f77b4", D3:"#2ca02c", D4:"#ff7f0e",
  D5:"#9467bd", D6:"#8c564b", D7:"#e377c2", D8:"#7f7f7f"
};
function luminance(hex){ const c = hex.replace('#',''); const r=parseInt(c.slice(0,2),16), g=parseInt(c.slice(2,4),16), b=parseInt(c.slice(4,6),16);
  return 0.299*r+0.587*g+0.114*b; }
function textColor(hex){ return luminance(hex)>160 ? "#000" : "#fff"; }
function rgba(hex, a=0.92){ const c = hex.replace('#',''); const r=parseInt(c.slice(0,2),16), g=parseInt(c.slice(2,4),16), b=parseInt(c.slice(4,6),16);
  return `rgba(${r},${g},${b},${a})`; }

// Points & route
const points = [
  ["æˆéƒ½",30.658,104.064,"D1",500],
  ["æ¾æ½˜",32.6386,103.5975,"D1",2850],
  ["å·ä¸»å¯ºé•‡",32.77682,103.61733,"D1",3000],
  ["ä¹å¯¨æ²Ÿ",33.20000,103.90000,"D1",2000],
  ["ç¥ä»™æ± ",33.25000,103.65000,"D2",3300],
  ["è¿­éƒ¨",34.0560,103.2219,"D2",3000],
  ["æ‰å°•é‚£",34.23595,103.18631,"D3",3000],
  ["æ´›å…‹ä¹‹è·¯",34.24800,103.18000,"D3",3100],
  ["ç±³æ‹‰æ—¥å·´ä½›é˜",35.00673,102.91556,"D3",2900],
  ["åˆä½œ",34.99837,102.90999,"D3",2900],
  ["å¤æ²³",35.20256,102.52173,"D4",2900],
  ["æ‹‰åœæ¥å¯º",35.19306,102.50694,"D4",2900],
  ["æ¡‘ç§‘è‰åŸ",35.11477,102.42877,"D4",3200],
  ["ç¢Œæ›²",34.59042,102.48892,"D4",3500],
  ["éƒæœ¨å¯º",34.09139,102.63639,"D4",3300],
  ["å”å…‹",33.4106,102.46754,"D5",3400],
  ["é˜¿å",32.90502,101.70192,"D6",3300],
  ["å„è«å¯º",32.98,101.38,"D6",3400],
  ["è²å®å¶åˆ™",33.233,101.08,"D6",4000],
  ["é˜¿åï¼ˆè¿”ï¼‰",32.90502,101.70192,"D6",3300],
  ["è§‚éŸ³æ¡¥",31.79968,101.65295,"D7",2500],
  ["ç‰ç§‘è‰åŸ",31.28858,101.17983,"D7",3800],
  ["å…šå²­",30.8521,101.9338,"D7",3200],
  ["ä¸¹å·´",30.877,101.886,"D7",1900],
  ["å·´éƒå±±",30.889,102.869,"D8",4460],
  ["æˆéƒ½ï¼ˆç»ˆï¼‰",30.658,104.064,"D8",500]
];
const order = [
  "æˆéƒ½","æ¾æ½˜","å·ä¸»å¯ºé•‡","ä¹å¯¨æ²Ÿ",
  "ç¥ä»™æ± ","è¿­éƒ¨",
  "æ‰å°•é‚£","æ´›å…‹ä¹‹è·¯","ç±³æ‹‰æ—¥å·´ä½›é˜","åˆä½œ",
  "å¤æ²³","æ‹‰åœæ¥å¯º","æ¡‘ç§‘è‰åŸ","ç¢Œæ›²","éƒæœ¨å¯º",
  "å”å…‹",
  "é˜¿å","å„è«å¯º","è²å®å¶åˆ™","é˜¿åï¼ˆè¿”ï¼‰",
  "è§‚éŸ³æ¡¥","ç‰ç§‘è‰åŸ","å…šå²­","ä¸¹å·´",
  "å·´éƒå±±","æˆéƒ½ï¼ˆç»ˆï¼‰"
];

const pt = {}; points.forEach(([n,lat,lon,day,elev])=>pt[n]={lat,lon,day,elev});

function haversineKm(lat1,lon1,lat2,lon2){ const R=6371; const dLat=(lat2-lat1)*Math.PI/180, dLon=(lon2-lon1)*Math.PI/180;
  const a=Math.sin(dLat/2)**2+Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
  return 2*R*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)); }
function roadKm(lat1,lon1,lat2,lon2){ return haversineKm(lat1,lon1,lat2,lon2)*1.35; }
function baselineTimeStr(km, elev1, elev2){ const speed = Math.max(elev1,elev2)>=2500 ? 45 : 60;
  const m = Math.round((km/speed)*60); return `${Math.floor(m/60)}h${(m%60).toString().padStart(2,'0')}m`; }

const segments=[];
let totalKm=0;
for(let i=0;i<order.length-1;i++){
  const a=order[i], b=order[i+1];
  const A=pt[a], B=pt[b];
  const dist = Math.round(roadKm(A.lat,A.lon,B.lat,B.lon));
  totalKm+=dist;
  const day = A.day;
  const timeStr = baselineTimeStr(dist, A.elev, B.elev);
  const amap = `https://uri.amap.com/navigation?from=${A.lon},${A.lat},${encodeURIComponent(a)}&to=${B.lon},${B.lat},${encodeURIComponent(b)}&mode=car&src=chatgpt`;
  segments.push({from:a,to:b,day,dist,timeStr,amap,A,B});
}

const map = L.map('map').setView([33.0,102.6], 6);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 18, attribution: '&copy; OpenStreetMap'
}).addTo(map);

// é¡¶éƒ¨ç»Ÿè®¡
function setTotals(total, remain){ document.getElementById('total_km').textContent = total; document.getElementById('remain_km').textContent = remain; }
setTotals(totalKm, totalKm);

// Anti-overlap helpers
const placed = [];
function willOverlap(ptA, threshold=22){
  for(const p of placed){ const dx=ptA.x - p.x, dy=ptA.y - p.y; if(Math.sqrt(dx*dx+dy*dy) < threshold) return true; }
  return false;
}
function spiralOffsets(n=24, step=0.001){ const arr=[]; for(let i=0;i<n;i++){ const ang=i*0.9, r=(i+1)*step; arr.push([Math.sin(ang)*r, Math.cos(ang)*r]); } return arr; }
const OFFSETS = spiralOffsets(28, 0.001);

// Draw segments & labels, keep refs
const polyRefs = [];
const labelRefs = [];
const checkRefs = [];

segments.forEach((seg, idx)=>{
  const color = dayColors[seg.day] || '#333';
  const fg = (luminance(color)>160 ? "#000" : "#fff");
  const bg = rgba(color, 0.92);
  const line = L.polyline([[seg.A.lat,seg.A.lon],[seg.B.lat,seg.B.lon]], {color, weight:5, opacity:0.95})
    .addTo(map)
    .bindTooltip("é«˜å¾·å¯¼èˆªï¼ˆç‚¹å‡»æ‰“å¼€ï¼‰", {sticky:true});
  line.on('click', ()=>{ window.open(seg.amap, '_blank'); });
  polyRefs[idx] = line;

  const mid = [(seg.A.lat+seg.B.lat)/2,(seg.A.lon+seg.B.lon)/2];
  const html = `<div class="chip" id="seglabel_${idx}" style="background:${bg} !important;color:${fg} !important;border-color:${color} !important;">
      <input type="checkbox" class="segchk" id="segcb_${idx}" data-idx="${idx}" data-dist="${seg.dist}" />
      <label for="segcb_${idx}" style="margin:0;cursor:pointer;">${seg.day} Â· ${seg.from} â†’ ${seg.to} Â· ${seg.dist} km Â· ${seg.timeStr}</label>
    </div>`;
  const marker = L.marker(mid, {icon: L.divIcon({className:'', html})}).addTo(map);
  labelRefs[idx] = marker;
  setTimeout(()=>{ const el = document.getElementById(`segcb_${idx}`); if(el) checkRefs[idx]=el; }, 0);
});

// Point labels with SAME look as route labels; anti-overlap
function addPointLabel(name, lat, lon, day, elev){
  const color = dayColors[day] || '#333';
  const fg = (luminance(color)>160 ? "#000" : "#fff");
  const bg = rgba(color, 0.90);
  L.circleMarker([lat,lon], {radius:4, weight:2, color, fillColor: color, fillOpacity:1}).addTo(map);

  let finalLat=lat, finalLon=lon, placedPt=null;
  for(const [dlat,dlon] of OFFSETS){
    const testLat = lat + dlat, testLon = lon + dlon;
    const ptScreen = map.latLngToLayerPoint([testLat, testLon]);
    if(!willOverlap(ptScreen)){ finalLat=testLat; finalLon=testLon; placedPt=ptScreen; break; }
  }
  if(!placedPt) placedPt = map.latLngToLayerPoint([finalLat, finalLon]);
  placed.push(placedPt);

  const tagHtml = `<div class="chip chip--point" style="background:${bg} !important;color:${fg} !important;border-color:${color} !important;">
    ${day} ${name}ï½œ${elev} m
  </div>`;
  L.marker([finalLat,finalLon], {icon: L.divIcon({className:'', html:tagHtml})}).addTo(map);
}

map.whenReady(()=>{
  points.forEach(([name,lat,lon,day,elev])=> addPointLabel(name,lat,lon,day,elev));
  const startName = points.find(p => p[3]==="D1")[0];
  const p = pt[startName];
  if(p){ const flagHtml = `<div class="flag" title="èµ·ç‚¹ï¼ˆD1ï¼‰">ğŸš©</div>`; L.marker([p.lat, p.lon], {icon: L.divIcon({className:'', html:flagHtml})}).addTo(map); }
});

// é¡ºåºå‹¾é€‰ + æŒä¹…åŒ–
const STORAGE_KEY = "chuan_gan_route_checked_indices_v2";
function persistState(){ const arr = checkRefs.map((el)=> el && el.checked ? 1 : 0); localStorage.setItem(STORAGE_KEY, JSON.stringify(arr)); }
function loadState(){ try{ const raw=localStorage.getItem(STORAGE_KEY); if(!raw) return null; const arr=JSON.parse(raw); return Array.isArray(arr)?arr.map(v=>v?1:0):null; }catch(e){ return null; } }

function applySequentialRules(){
  checkRefs.forEach(el=>{ if(el) el.disabled=true; });
  let firstUnchecked = checkRefs.findIndex(el=> el && !el.checked);
  if(firstUnchecked === -1) firstUnchecked = checkRefs.length-1;
  if(checkRefs[firstUnchecked]) checkRefs[firstUnchecked].disabled=false;
}
function updateVisualsFromChecks(){
  let checkedDist=0;
  checkRefs.forEach((el,i)=>{
    if(!el) return;
    const dist = parseInt(el.getAttribute('data-dist')||'0',10);
    const poly = polyRefs[i];
    const labelMarker = labelRefs[i];
    if(el.checked){ checkedDist += dist; if(poly&&poly._path){ poly._path.style.filter="saturate(35%) brightness(0.95)"; poly._path.style.opacity="0.45"; }
      if(labelMarker){ const nd=labelMarker.getElement(); if(nd) nd.classList.add('dimmed'); } }
    else { if(poly&&poly._path){ poly._path.style.filter=""; poly._path.style.opacity="0.95"; }
      if(labelMarker){ const nd=labelMarker.getElement(); if(nd) nd.classList.remove('dimmed'); } }
  });
  setTotals(totalKm, Math.max(0,totalKm-checkedDist));
}
function restoreFromStorage(){
  const arr = loadState();
  if(!arr){ applySequentialRules(); updateVisualsFromChecks(); return; }
  let last=-1;
  for(let i=0;i<arr.length;i++){
    if(arr[i]===1){
      if(i===last+1){ if(checkRefs[i]) checkRefs[i].checked=true; last=i; } else { break; }
    }else{ break; }
  }
  applySequentialRules();
  updateVisualsFromChecks();
}

document.addEventListener('change', e=>{
  if(e.target && e.target.classList.contains('segchk')){
    const idx = parseInt(e.target.getAttribute('data-idx'),10);
    if(Number.isFinite(idx)){
      const prev = idx-1;
      if(prev>=0 && (!checkRefs[prev] || !checkRefs[prev].checked)){
        e.target.checked=false; return;
      }
      if(!e.target.checked){
        for(let j=idx+1;j<checkRefs.length;j++){ if(checkRefs[j]) checkRefs[j].checked=false; }
      }
      applySequentialRules();
      updateVisualsFromChecks();
      persistState();
    }
  }
});

window.addEventListener('load', ()=>{ setTimeout(restoreFromStorage, 100); });
</script>
</body>
</html>
"""
path = "/mnt/data/å·ç”˜ç¯çº¿-ç»Ÿä¸€åº•è‰²å­—ä½“-é¡ºåºæŒä¹…åŒ–-é˜²é®æŒ¡-çº¯å‡€ç‰ˆ.html"
with open(path, "w", encoding="utf-8") as f:
    f.write(html)
path
